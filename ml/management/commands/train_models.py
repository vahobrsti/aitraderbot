# ml/management/commands/train_models.py
"""
Train long/short ML models from feature CSV.
Supports holdout validation, walk-forward, and production modes.
"""

import shutil
import subprocess
from datetime import datetime
from pathlib import Path

from django.core.management.base import BaseCommand

from ml.training import (
    train_long_model_with_holdout,
    train_short_model_with_holdout,
    train_with_walk_forward,
    train_production_model,
    FeatureMode,
)

S3_BUCKET = "aioptionstradermodel"

# Common AWS CLI installation paths (for cron environments with minimal PATH)
AWS_CLI_PATHS = [
    "/usr/local/bin/aws",
    "/usr/bin/aws",
    "/home/ubuntu/.local/bin/aws",
    "/root/.local/bin/aws",
]


def find_aws_cli() -> str:
    """Find the AWS CLI binary, checking PATH and common locations."""
    # First try PATH (works in interactive shells)
    aws_path = shutil.which("aws")
    if aws_path:
        return aws_path
    
    # Fall back to common installation paths (for cron)
    for path in AWS_CLI_PATHS:
        if Path(path).exists():
            return path
    
    raise FileNotFoundError(
        "AWS CLI not found. Install it or add its path to AWS_CLI_PATHS."
    )


def backup_models_to_s3(out_dir: Path, stdout_write) -> None:
    """Backup existing models to S3 before overwriting."""
    timestamp = datetime.now().strftime("%Y-%m-%dT%H-%M-%S")
    
    try:
        aws_cli = find_aws_cli()
    except FileNotFoundError as e:
        stdout_write(f"⚠ Skipping S3 backup: {e}")
        return
    
    for model_name in ["long_model.joblib", "short_model.joblib"]:
        local_path = out_dir / model_name
        if local_path.exists():
            s3_key = f"models/{model_name.replace('.joblib', '')}_{timestamp}.joblib"
            s3_uri = f"s3://{S3_BUCKET}/{s3_key}"
            
            result = subprocess.run(
                [aws_cli, "s3", "cp", str(local_path), s3_uri],
                capture_output=True,
                text=True,
            )
            
            if result.returncode == 0:
                stdout_write(f"✓ Backed up {model_name} → {s3_uri}")
            else:
                stdout_write(f"✗ Failed to backup {model_name}: {result.stderr}")


class Command(BaseCommand):
    help = "Train long/short ML models from the feature CSV."

    def add_arguments(self, parser):
        parser.add_argument(
            "--features_csv",
            type=str,
            default="features_14d_5pct.csv",
            help="Path to the features CSV generated by build_features.",
        )
        parser.add_argument(
            "--out_dir",
            type=str,
            default="models",
            help="Directory to save trained models.",
        )
        parser.add_argument(
            "--no_short",
            action="store_true",
            help="Only train the long model, skip the short model.",
        )
        parser.add_argument(
            "--mode",
            type=str,
            choices=["pure", "hybrid"],
            default="hybrid",
            help="Feature mode: 'pure' excludes all regime signals, 'hybrid' keeps regimes but excludes trading signals.",
        )
        parser.add_argument(
            "--lag",
            type=int,
            default=1,
            help="Decision lag in days (shift features to avoid lookahead). 1=trade next day (default), 0=trade at close.",
        )
        parser.add_argument(
            "--walk-forward",
            action="store_true",
            help="Use walk-forward validation with 6 rolling folds, then final test on 2025.",
        )
        parser.add_argument(
            "--production",
            action="store_true",
            help="Train on ALL available data (including 2025) for deployment. No holdout.",
        )
        parser.add_argument(
            "--n-features",
            type=int,
            default=None,
            help="Select top N features by importance to reduce overfitting. Default: use all features.",
        )

    def handle(self, *args, **options):
        csv_path = Path(options["features_csv"])
        out_dir = Path(options["out_dir"])
        mode = FeatureMode(options["mode"])
        decision_lag = options["lag"]
        use_walk_forward = options["walk_forward"]
        use_production = options["production"]
        n_features = options["n_features"]

        if not csv_path.exists():
            self.stderr.write(self.style.ERROR(f"Features CSV not found: {csv_path}"))
            return

        out_dir.mkdir(parents=True, exist_ok=True)

        long_model_path = out_dir / "long_model.joblib"
        short_model_path = out_dir / "short_model.joblib"

        if use_production:
            # Production mode: train on ALL data
            self.stdout.write(self.style.WARNING("PRODUCTION MODE: Training on ALL data (no holdout)"))
            
            # Backup existing models to S3 before overwriting
            self.stdout.write("Backing up existing models to S3...")
            backup_models_to_s3(out_dir, self.stdout.write)
            
            self.stdout.write(self.style.MIGRATE_HEADING("Training LONG production model..."))
            train_production_model(
                csv_path, long_model_path,
                label_col="label_good_move_long",
                mode=mode, decision_lag=decision_lag, n_features=n_features
            )

            if not options["no_short"]:
                self.stdout.write(self.style.MIGRATE_HEADING("Training SHORT production model..."))
                train_production_model(
                    csv_path, short_model_path,
                    label_col="label_good_move_short",
                    mode=mode, decision_lag=decision_lag, n_features=n_features
                )

        elif use_walk_forward:
            # Walk-forward validation mode
            self.stdout.write(self.style.MIGRATE_HEADING("WALK-FORWARD: Training LONG model..."))
            train_with_walk_forward(
                csv_path, long_model_path, 
                label_col="label_good_move_long",
                mode=mode, decision_lag=decision_lag, n_features=n_features
            )

            if not options["no_short"]:
                self.stdout.write(self.style.MIGRATE_HEADING("WALK-FORWARD: Training SHORT model..."))
                train_with_walk_forward(
                    csv_path, short_model_path,
                    label_col="label_good_move_short",
                    mode=mode, decision_lag=decision_lag, n_features=n_features
                )
        else:
            # Standard holdout mode
            self.stdout.write(self.style.MIGRATE_HEADING("Training LONG model..."))
            train_long_model_with_holdout(csv_path, long_model_path, mode=mode, decision_lag=decision_lag)

            if not options["no_short"]:
                self.stdout.write(self.style.MIGRATE_HEADING("Training SHORT model..."))
                train_short_model_with_holdout(csv_path, short_model_path, mode=mode, decision_lag=decision_lag)

        self.stdout.write(self.style.SUCCESS("Model training completed."))

